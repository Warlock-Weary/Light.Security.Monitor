definition(
    name: "Light Security Monitor",
    namespace: "LSM",
    author: "WarlockWeary + ChatGPT + Grok",
    description: "Monitor Door and Window sensors and Door lock, change bulb color, and send notifications with time and logging control.",
    category: "Safety & Security",
    iconUrl: "",
    iconX2Url: "",
    singleInstance: false
)

preferences {
    section("Select devices to monitor:") {
        input "contacts", "capability.contactSensor", title: "Contact Sensors", multiple: true, required: true
        input "lock", "capability.lock", title: "Z-Wave Door Lock", required: true
    }
    section("Select device to control:") {
        input "nightLight", "capability.colorControl", title: "Night Light Bulb", required: true
    }
    section("Color Settings:") {
        input "secureColor", "enum", title: "Color when SECURE (locked + closed)", required: false, options: colorOptions(), defaultValue: "Green"
        input "alertColor", "enum", title: "Color when ALERT (unlocked or open)", required: false, options: colorOptions(), defaultValue: "Red"
    }
    section("Notification settings:") {
        input "notifyDevices", "capability.notification", title: "Notification Device(s)", multiple: true, required: false
        input "sendPush", "bool", title: "Send Notifications?", defaultValue: true
        input "repeatMinutes", "number", title: "Repeat Notification Every (minutes)", defaultValue: 15
        input "startTime", "time", title: "Notify Only After (start time)", required: true
        input "endTime", "time", title: "Notify Only Before (end time)", required: true
    }
    section("Logging") {
        input "logEnable", "bool", title: "Enable debug logging?", defaultValue: true
        input "logAutoDisable", "bool", title: "Auto-disable logging after 30 minutes?", defaultValue: true
    }
}

def colorOptions() {
    return [
        "Red", "Green", "Blue", "Yellow", "Purple", "Pink", "White", "Orange", "Cyan", "Magenta"
    ]
}

def installed() {
    initialize()
}

def updated() {
    unsubscribe()
    unschedule()
    initialize()
    scheduleLogDisable()
}

def initialize() {
    subscribe(contacts, "contact", eventHandler)
    subscribe(lock, "lock", eventHandler)
    runIn(2, checkStatus)
    state.notificationCount = 0
    logInfo("Security Monitor initialized")
}

def eventHandler(evt) {
    logInfo("Event received: ${evt.device.displayName} - ${evt.name}: ${evt.value}")
    checkStatus()
}

def checkStatus() {
    try {
        def anyOpen = false
        def isUnlocked = false
        def openDevices = []
        
        if (contacts) {
            contacts.each { sensor ->
                if (sensor) {
                    def contactState = sensor.currentValue("contact")
                    if (contactState == "open") {
                        anyOpen = true
                        openDevices << sensor.displayName
                    }
                }
            }
        }
        
        if (lock) {
            def lockState = lock.currentValue("lock")
            isUnlocked = (lockState == "unlocked")
        }
        
        logInfo("Status check - Open sensors: ${anyOpen ? openDevices.join(', ') : 'None'}, Unlocked: ${isUnlocked}")
        
        if (anyOpen || isUnlocked) {
            setNightLight(alertColor ?: "Red")
            if (inTimeWindow()) {
                scheduleNotification()
            } else {
                logInfo("Alert condition detected but outside notification time window")
            }
        } else {
            setNightLight(secureColor ?: "Green")
            unschedule("sendRepeatNotification")
            state.notificationCount = 0
            logInfo("All secure - notifications stopped")
        }
    } catch (Exception e) {
        log.error "Error in checkStatus: ${e.message}"
    }
}

def setNightLight(colorName) {
    try {
        if (!nightLight) {
            log.warn "Night light device not configured"
            return
        }
        
        def colorMap = [
            "Red":     [hue: 0,   saturation: 100],
            "Green":   [hue: 33,  saturation: 100],
            "Blue":    [hue: 66,  saturation: 100],
            "Yellow":  [hue: 16,  saturation: 100],
            "Purple":  [hue: 80,  saturation: 100],
            "Pink":    [hue: 90,  saturation: 40],
            "White":   [hue: 52,  saturation: 0],
            "Orange":  [hue: 10,  saturation: 100],
            "Cyan":    [hue: 50,  saturation: 100],
            "Magenta": [hue: 83,  saturation: 100]
        ]
        
        def chosen = colorMap[colorName] ?: colorMap["Red"]
        if (nightLight.hasCommand("on")) nightLight.on() // Ensure bulb is on
        if (nightLight.hasCommand("setColor")) {
            nightLight.setColor(chosen + [level: 100])
        } else {
            if (nightLight.hasCommand("setHue")) nightLight.setHue(chosen.hue)
            if (nightLight.hasCommand("setSaturation")) nightLight.setSaturation(chosen.saturation)
            if (nightLight.hasCommand("setLevel")) nightLight.setLevel(100)
        }
        logInfo("Color set to: ${colorName}")
    } catch (Exception e) {
        log.error "Error setting night light color: ${e.message}"
    }
}

def inTimeWindow() {
    try {
        if (!startTime || !endTime) {
            logInfo("Time window not configured, defaulting to always active")
            return true
        }
        
        def now = new Date()
        def start = timeToday(startTime)
        def end = timeToday(endTime)
        
        if (end < start) {
            return now.after(start) || now.before(end)
        } else {
            return now.after(start) && now.before(end)
        }
    } catch (Exception e) {
        log.error "Error checking time window: ${e.message}"
        return true
    }
}

def scheduleNotification() {
    try {
        unschedule("sendRepeatNotification")
        sendRepeatNotification()
        if (repeatMinutes && repeatMinutes > 0) {
            switch(repeatMinutes) {
                case 1:
                    runEvery1Minute("sendRepeatNotification")
                    break
                case 5:
                    runEvery5Minutes("sendRepeatNotification")
                    break
                case 10:
                    runEvery10Minutes("sendRepeatNotification")
                    break
                case 15:
                    runEvery15Minutes("sendRepeatNotification")
                    break
                case 30:
                    runEvery30Minutes("sendRepeatNotification")
                    break
                case 60:
                    runEvery1Hour("sendRepeatNotification")
                    break
                default:
                    logInfo("Using custom interval of ${repeatMinutes} minutes")
                    break
            }
            logInfo("Scheduled repeat notifications every ${repeatMinutes} minutes")
        } else {
            log.warn "Invalid repeatMinutes value: ${repeatMinutes}. Notifications will not repeat."
        }
    } catch (Exception e) {
        log.error "Error scheduling notifications: ${e.message}"
    }
}

def sendRepeatNotification() {
    try {
        state.notificationCount = (state.notificationCount ?: 0) + 1
        if (state.notificationCount > 10) {
            logInfo("Notification limit (10) reached. Stopping repeat notifications.")
            unschedule("sendRepeatNotification")
            return
        }
        
        def anyOpen = false
        def isUnlocked = false
        def openDevices = []
        
        if (contacts) {
            contacts.each { sensor ->
                if (sensor && sensor.currentValue("contact") == "open") {
                    anyOpen = true
                    openDevices << sensor.displayName
                }
            }
        }
        
        if (lock) {
            isUnlocked = (lock.currentValue("lock") == "unlocked")
        }
        
        if ((anyOpen || isUnlocked) && inTimeWindow() && sendPush && notifyDevices) {
            def nowStr = new Date().format("hh:mm a", location.timeZone ?: TimeZone.getDefault())
            def openList = openDevices.join(', ')
            def msg = ""

            if (anyOpen && !isUnlocked) {
                msg = "⚠️ Alert: ${openList} open at ${nowStr}."
            } else if (!anyOpen && isUnlocked) {
                msg = "🚨 Lock: ${lock.displayName} is UNLOCKED at ${nowStr}."
            } else if (anyOpen && isUnlocked) {
                msg = "🚨 Doors/Locks: ${openList} and ${lock.displayName} is UNLOCKED at ${nowStr}."
            }

            if (msg) {
                notifyDevices.each { device ->
                    if (device && device.hasCommand("deviceNotification")) {
                        device.deviceNotification(msg)
                        logInfo("Notification sent to: ${device.displayName}")
                    } else {
                        log.warn "Device ${device?.displayName} does not support notifications"
                    }
                }
            }
            
            if (repeatMinutes && ![1, 5, 10, 15, 30, 60].contains(repeatMinutes) && repeatMinutes > 0) {
                runIn(repeatMinutes * 60, "sendRepeatNotification")
            }
        } else {
            unschedule("sendRepeatNotification")
            logInfo("Stopping repeat notifications - conditions resolved or outside time window")
        }
    } catch (Exception e) {
        log.error "Error sending notification: ${e.message}"
    }
}

def logInfo(msg) {
    if (logEnable) log.info "-= Security Monitor =- ${msg}"
}

def scheduleLogDisable() {
    if (logEnable && logAutoDisable) {
        runIn(1800, disableLogging)
        logInfo("Auto-disable logging scheduled for 30 minutes")
    }
}

def disableLogging() {
    app.updateSetting("logEnable", [value: "false", type: "bool"])
    log.info "-= Security Monitor =- Debug logging automatically disabled"
}